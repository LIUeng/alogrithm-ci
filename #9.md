# 数据结构与算法

## 归并/快速排序算法

`问题思考`

- 如何通过快速排序算法找出第K大元素

### 归并排序

![归并排序分析](https://imgkr.cn-bj.ufileos.com/9573b487-6e67-4a0a-949f-f3affba90bcc.png)

- 分冶思想：大问题分解成子问题来解决

- 归并是稳定的排序算法

- 归并排序的时间复杂度分析

> 递归的适用场景是，一个问题 a 可以分解为多个子问题 b、c，那求解问题 a 就可以分解为求解问题 b、c。问题 b、c 解决之后，我们再把 b、c 的结果合并成 a 的结果

```md
// 定义求解a的时间是T(a), 求解b, c的时间分别为T(b), T(c)
// K等于b, c子问题合并成a问题所消耗的时间
T(a) = T(b) + T(c) + K
```

`归并排序`
```md
// n个元素进行归并排序需要的时间为T(n), 分解两个子问题所需要的时间则是T(2/n), 合并两个数组的时间复杂度为O(1)
T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n>1

// 递推
T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
     
// 当T(n/2^k)=T(1)时，n/2^k = 1, k=log2n 代入上述公式，得到
T(n)=Cn+nlog2n

// 时间复杂度即为nlog2n
```

- 归并排序的空间复杂度

> 代码中申请了一个temp临时数组，在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)

[归并排序代码](https://github.com/LIUeng/alogrithm-ci/blob/master/%239.js)

### 快速排序

![快速排序分区](https://imgkr.cn-bj.ufileos.com/a5775de1-5205-4234-8ebd-cf7d86f5a5fe.png)

- 快速排序可以是原地排序算法，代码中可以体现，空间复杂度为O(1)
- 快速排序不是一个稳定的排序算法

[快速排序代码](https://github.com/LIUeng/alogrithm-ci/blob/master/%239.js)

### 归并VS快速排序

![比较](https://imgkr.cn-bj.ufileos.com/9b630ef8-2f28-4ef4-a94f-b906207ad019.png)

> 归并排序的处理方式是由下到上，先处理子问题，然后再合并；快速排序算法则相反，由上到下，先分区，再处理子问题；它们的时间复杂度都是nlog2n；归并算法是非原地排序算法，占用空间较大；快速排序可以设计成原地排序算法。

### 如何通过快速排序算法找到第K大元素

[找出第K大元素代码](https://github.com/LIUeng/alogrithm-ci/blob/master/%239.js)

## 快速排序算法的优化

`思考`

- 优化快速排序

![排序算法比较](https://imgkr.cn-bj.ufileos.com/290b18c0-b9de-4603-aec1-4bc7c9ccf43a.png)

> 快速排序,如果数据是有序或者接近有序的条件下，分区每次选择最后一个数据，快速排序会非常糟糕，时间复杂度退化成O(n^2)

1. 三数取中法

首、尾、中间取值，比较大小，取中间值数

2. 随机法

随机取一个值，进行分区

[快速排序优化代码](https://github.com/LIUeng/alogrithm-ci/blob/master/%239-optimize.js)

[引用地址](https://time.geekbang.org/column/article/41913)